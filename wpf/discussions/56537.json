[
  {
    "Id": "191064",
    "ThreadId": "56537",
    "Html": "<p>It&rsquo;s not that easy to bind a ShortCut Key to a DelegateCommand because of a annoying WPF issue.<br>&nbsp;<br>I have seen that you solved this problem by introducing the CommandReference class. The following code extract is from the MainView.xaml of the ContactBook solution (v 0.1):<br>&nbsp;<br>&lt;Window.Resources&gt;<br>&nbsp;&nbsp;&nbsp; &lt;!-- Allows a KeyBinding to be associated with a command defined in the View Model&nbsp; --&gt;<br>&nbsp;&nbsp;&nbsp; &lt;c:<strong>CommandReference</strong> x:Key=&quot;ExitCommandReference&quot; Command=&quot;{Binding ExitCommand}&quot; /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;c:CommandReference x:Key=&quot;ClearContactBookCommandReference&quot; Command=&quot;{Binding ClearContactBookCommand}&quot; /&gt;<br>&lt;/Window.Resources&gt;</p>\r\n<p>&lt;Window.InputBindings&gt;<br>&nbsp;&nbsp;&nbsp; &lt;KeyBinding Key=&quot;X&quot; Modifiers=&quot;Control&quot; Command=&quot;{StaticResource ExitCommandReference}&quot; /&gt; <br>&nbsp;&nbsp;&nbsp; &lt;KeyBinding Key=&quot;B&quot; Modifiers=&quot;Control&quot; Command=&quot;{StaticResource ClearContactBookCommandReference}&quot; /&gt;<br>&lt;/Window.InputBindings&gt;</p>\r\n<p>That&rsquo;s a nice workaround. However, maybe you are interested to see an alternative solution to overcome this WPF issue:</p>\r\n<p>Best Practices: How to implement ShortCut Keys with DelegateCommands<br><a href=\"http://compositeextensions.codeplex.com/Thread/View.aspx?ThreadId=52980\">http://compositeextensions.codeplex.com/Thread/View.aspx?ThreadId=52980</a>&nbsp;</p>\r\n<p>jbe</p>",
    "PostedDate": "2009-05-16T11:43:19.363-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "191661",
    "ThreadId": "56537",
    "Html": "<p>Hi Jbe-</p>\r\n<p>You're correct in that the CommandReference is to work around the issue with the key binding. In putting the CommandReference in the template &amp; toolkit, we primarily wanted to provide a solution (rather than&nbsp;'the' solution)&nbsp;that would be inline with the concept of M-V-VM, and&nbsp;if possible avoid having to write code-behind.</p>\r\n<p>Having said that, I'm sure many will be happy to learn that we are fixing this in WPF 4.0, where you will be able to bind to an ICommand directly from the KeyBinding in XAML. Thanks!</p>",
    "PostedDate": "2009-05-18T15:34:04.643-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "192455",
    "ThreadId": "56537",
    "Html": "<p>That sounds great, Patrick.</p>\r\n<p>Any ideas on how the binding syntax is going to look for that?&nbsp;</p>\r\n<p>How are you going to be able to specify/distinguish between collisions?&nbsp; Will there be a way to qualify the command binding?</p>\r\n<p>From a side note, I would really be interested not only in the template side of things, but in a tricked-out class designer to facilitate the commanding process.&nbsp; Just shooting from the hip, here, but if you used partial classes and a separate file it would keep the code clean and allow for an interesting design story for the drudgework of building up commands.</p>\r\n<p>Cheers,</p>\r\n<p>-James</p>",
    "PostedDate": "2009-05-20T10:16:59.317-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "192634",
    "ThreadId": "56537",
    "Html": "<p>Hi James-</p>\r\n<p>The syntax will actually be closer to what you are normally used to in WPF. So, instead of having KeyBinding's Command property be limited to static references, it will allow for data binding directly to the view model, similar to how you could do so with Button's Command property. In markup, something like &lt;KeyBinding Command={Binding ViewModelCommand} /&gt; instead of having to do &lt;KeyBinding Command={StaticResource ViewModelCommandReference} /&gt; and having the ViewModelCommandReference call the ViewModelCommand. Pretty simple, but saves from having to work around the limitation.</p>\r\n<p>With respect to resolving which binding to use, the same rules that normally apply with a control's data context will now apply with the key binding. In other words, if you define a key binding locally that's different from a &quot;root&quot; key binding, the local one will take precedent if that element has focus.</p>\r\n<p>There is work underway in VS 2010 to improve the design experience of WPF and data binding, which hopefully will help address some of the pain. If you have some time, I would suggest giving the recently released Beta1 a try, and keeping an eye out for upcoming features. Link: http://www.microsoft.com/visualstudio/en-us/products/2010/default.mspx</p>\r\n<p>Thanks again for your support, we appreciate it!</p>",
    "PostedDate": "2009-05-20T20:10:20.497-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]