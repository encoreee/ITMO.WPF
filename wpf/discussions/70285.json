[
  {
    "Id": "239368",
    "ThreadId": "70285",
    "Html": "<p>Besides the Command binding in MVVM, other actions in MVVM and MVP are very similar .</p>\r\n<p>The ViewModel in MVVM is like the Presenter in MVP pattern .</p>\r\n<p>Could someone point me out what's the obviously differences of these two architecture ?</p>\r\n<p>Thanks .</p>",
    "PostedDate": "2009-09-27T20:05:11.367-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "243047",
    "ThreadId": "70285",
    "Html": "<p>According to my understanding...</p>\r\n<p>In MVVM:</p>\r\n<ul>\r\n<li>View is aware of ViewModel (because a View generally has data bindings&nbsp;and commands to the&nbsp;ViewModel)</li>\r\n<li>ViewModel is aware of Model (because a ViewModel generally holds a reference to the Model as a private field)</li>\r\n<li>ViewModel is <strong>not</strong> aware of View</li>\r\n<li>Model is <strong>not</strong> aware of ViewModel</li>\r\n<li>View and Model are <strong>not</strong> directly aware of each other (although some bind their View to static, non-changing data directly to the model).</li>\r\n</ul>\r\n<p>In MVP:</p>\r\n<ul>\r\n<li>Presenter is aware of the View (because the Presenter can control the view via a defined IView interface)</li>\r\n<li>Presenter is aware of the Model (because a&nbsp;Presenter generally holds a reference to the Model as a private field)</li>\r\n<li>The level of awareness between the different pieces depends on if it's the <a href=\"http://martinfowler.com/eaaDev/PassiveScreen.html\">Passive View</a> flavor or <a href=\"http://martinfowler.com/eaaDev/SupervisingPresenter.html\">Supervising Controller</a>&nbsp;flavor of MVP.</li>\r\n</ul>\r\n<p>Some implications:</p>\r\n<ul>\r\n<li>In MVVM, since the viewmodel knows nothing of the view, you can swap out the view with a completely different view without any effect to the remainder of the application. (In MVP, the presenter has to know what the view is so that it can control it, so when a view is replaced, the presenter has to be updated.) Big benefit for MVVM here is the ability to unit test - one can replace the view with a simulated view, the unit test harness. The test harness reads the properties of the viewmodel, which is what a view would bind to, and the test harness can call methods on the viewmodel, which is what a view would do via the commands.</li>\r\n<li>In MVP, the presenter is responsible for keeping the state of the view in sync with the state of the model, and vice versa. In MVVM, the viewmodel is an abstraction of the view itself so the state of the view is actually maintained in the viewmodel.</li>\r\n</ul>\r\n<p>I&nbsp;wish there were some better language to describe this more clearly -- even I get frustrated that there aren't better ways to illustrate this sort of stuff.</p>",
    "PostedDate": "2009-10-07T10:38:47.107-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]