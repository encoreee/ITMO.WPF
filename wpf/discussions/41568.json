[
  {
    "Id": "137946",
    "ThreadId": "41568",
    "Html": "Is there any way to hook into the DataGrid V1's code execution path between the points where the DataGridRow's bound object's IEditableObject.EndEdit() returns, but before the row is taken out of edit mode, and implement logic determining whether the row should be allowed to exit edit mode or not? And if so, how do I do it?<br>\r\n<br>\r\nThe problem is this: I have implemented (on the business object, which implements IEditableObject and INotifyPropertyChanged) logic in EndEdit() that attempts to store the object and handles the case where the underlying data storage rejects the new or changed object. If such rejection occurs, the user is currently notified (via a message on the application's status bar) but unlike the current situation, the row should not exit editing mode as it has not been committed to the underlying data storage, only to the application's own ObservableCollection which is only used for caching what is a potentially large data set. Ideally, the user should then be faced with the choice of fixing the problem and re-trying the commit, or aborting their changes (one or two Escape key presses, restoring the &quot;known good&quot; row state). Failing that, even being able to explicitly cancel the business object edit, which would propagate NotifyPropertyChanges to the DataGrid, would be acceptable. The RowEditEnding event with its e.Cancel is <em>almost</em> what I want, except it executes <em>before</em> IEditableObject.EndEdit() rather than after. The business object implements an IsDirty flag that is useful for this, if only I can get access to the object at the correct point during code execution.<br>\r\n<br>\r\nBusiness rules mandate that I cannot rely on a &quot;try to save, then actually save&quot; methodology; I have to attempt to save the business object to the underlying data storage, an operation which will either succeed or fail, and then deal with whatever the result of that is. Also note that I am dealing with potentially dozens of different types of business object, some with very few similarities, and want to avoid code duplication as much as possible.<br>\r\n<br>\r\nI looked over the DataGrid source code but couldn't quite figure out how to add an event like such an AfterRowEditEnd, but if that is the only reasonable option I am willing to go that route as well. In that case, any pointers or suggestions that you may be able to provide would be greatly appreciated.<br>\r\n<br>\r\nOf course, the <em>easy</em> solution would be if IEditableObject.EndEdit() returned a bool indicating whether the end edit was successful or not, but I doubt that interface is going to be changed any time soon...<br>\r\n",
    "PostedDate": "2008-12-05T02:51:17.423-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "137972",
    "ThreadId": "41568",
    "Html": "Have you tried using item level validation?  You can set the validation step to CommittedValue which will update the underlying data and do a validation after that.  There are some limitations with validation that are noted here, <a href=\"http://www.codeplex.com/wpf/Wiki/View.aspx?title=Validation&referringTitle=Tips %26 Tricks\">http://www.codeplex.com/wpf/Wiki/View.aspx?title=Validation&amp;referringTitle=Tips%20%26%20Tricks</a>.  \r\n",
    "PostedDate": "2008-12-05T05:29:47.097-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "138003",
    "ThreadId": "41568",
    "Html": "Vinsibal,<br>\r\n<br>\r\nNo, I hadn't, but thank you. After looking around a little and moving some code around, item level validation seems to be just about exactly what I was looking for. Thank you! \r\n",
    "PostedDate": "2008-12-05T06:44:01.227-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]