[
  {
    "Id": "146152",
    "ThreadId": "43954",
    "Html": "I wanted to let you know that there are some issues with the DataGrid canceled edits and NewItemPlaceHolders.<div>If a BeginningEdit event handler cancels the edit (by setting DataGridBeginningEditEventArgs.Cancel to true) , the control will correctly remove the new item it added to the ItemSource and then un-collapse the NewItemPlaceHolder row.</div><div><br></div><div>It does this by calling the private method  DataGrid.CancelRowItem().</div><div><br></div><div>The RowEditEnding event, however, does not remove the new row when a call to RowEditEnding sets Cancel to rue.</div><div>This can cause some problems.<br></div><div>To see why, consider the following sequence of events:</div><div><br></div><div><ol id=false>    <li>The user starts editing the NewItemPlaceHolder row</li>    <li>The control hides the new item place holder row, adds a new item to the control's item source, adds a new row to the grid for the new item, hides the NewItemPlaceHolder row, and transfers the selection state from the NewItemPlaceHolder to the new row</li>    <li>The user does some editing, and then clicks on a new row in the grid</li>    <li>The control fires a RowEditEnding event</li>    <li>A handler for the RowEditEnding event sets DataGridRowEditEndingEventArgs.Cancel to true</li>    <li>Because Cancel is set to true, the row is not committed</li>    <li>Focus is then set to the new grid row</li></ol></div><div>This ends up leaving the control in a messed up state.</div><div><br></div><div>The NewItemPlaceHolder row is still hidden, preventing the user from adding any more new rows.<br></div><div><br></div><div>The next time the &quot;new&quot; row is edited, because it's not the NewItemPlaceHolder row, the control acts as if it was editing an existing row, not a new one.</div><div>The end result is that the user can no longer edit any new rows. That is obviously a bug.<br></div><div><br></div><div>For me, I have a grid configured to automatically edit on click, using one of the samples from the &quot;Tips and Tricks&quot; session.</div><div>This mostly gives me the behavior that I want. A side effect of configuring things this way, when combined with this bug, is that the user clicking on the place holder row,</div><div>and then clicking somewhere else, ends up adding a new row to the grid, which clearly was not when the user intended to happen (if they wanted a new row, they would have entered in some values into the grid).</div><div><br></div><div>I can detect this (all the data in the row will have default values), and cancel the add.</div><div>This bug prevents me from doing that.</div><div><br></div><div>So, I hacked up the source code for the grid to enable this.</div><div><br></div><div>In my local copy of the source, I made 2 changes:</div><div><ol id=false>    <li>I updated OnExecutedCommitEdit to call CancelRowItem() when both IsAddingNewItem() and rowEditEndingEventArgs.Cancel are true</li>    <li>I changed OnEnterKeyDown() to not increment the current row if the current row ends up being the NewItemPlaceHolder row.</li></ol>Now, these edits seem to be OK to me.</div><div><br></div><div>However, I don't know the source for the DataGrid very well. I only spent in total about an hour looking at the code and making the change, so I wanted to make sure that there isn't something major that I'm missing.</div><div><br>Does any one know if there are any scenarios where my hacky edits will screw stuff up?</div><div><br></div><div><br></div>",
    "PostedDate": "2009-01-11T18:22:45.02-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]