[
  {
    "Id": "172900",
    "ThreadId": "51553",
    "Html": "Forgive me if I overlooked an already brought up discussion. I am trying to implement a LINQ to Entities model (my only solid option working with an Oracle DB) in a WPF application. <br>\r\n<br>\r\nI think I am off to the right start but I cannot seem to make the two-way binding actually perform the CRUD functionality against the db.<br>\r\n<br>\r\n<span><strong>Here's the XAML:</strong><br>\r\n<br>\r\n<em>&lt;toolkit:DataGrid Name=&quot;dgCustomers&quot; AutoGenerateColumns=&quot;False&quot; &gt;<br>\r\n&lt;toolkit:DataGrid.Columns&gt;<br>\r\n&lt;toolkit:DataGridTextColumn Header=&quot;First Name&quot; Binding=&quot;{Binding FirstName, Mode=TwoWay}&quot; /&gt;<br>\r\n&lt;toolkit:DataGridTextColumn Header=&quot;Initial&quot; Binding=&quot;{Binding MiddleInitial, Mode=TwoWay}&quot; /&gt;<br>\r\n...<br>\r\n&lt;/toolkit:DataGrid.Columns&gt;<br>\r\n&lt;/toolkit:DataGrid&gt;<br>\r\n<br>\r\n</em><strong>Here's the C#:</strong><em><br>\r\n<br>\r\nvoid Window1_Loaded(object sender, RoutedEventArgs e)<br>\r\n{<br>\r\nOracleTestEntities entities = new OracleTestEntities();<br>\r\ndgCustomers.ItemsSource = entities.Customers;<br>\r\n}</em></span><em><br>\r\n</em><br>\r\n<br>\r\nThe data is displayed properly, and the data grid seems to work, allowing me to edit columns, add a new row, etc... but when I check back in Oracle and query the table, nothing is altered in any manner.<br>\r\n<br>\r\nWhen using the LINQ to Entities style data source, do I need to manually write the C# code performed on those events? Anyone have ideas? Examples?<br>\r\n<br>\r\nThank you,<br>\r\n",
    "PostedDate": "2009-03-27T12:34:11.443-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "172913",
    "ThreadId": "51553",
    "Html": "Hi trov2k,<br>\r\n<br>\r\nThe changes made to the datagrid will update only the in memory entities (be it SQL or Oracle). Yes you need to write custom code to commit to the actual database.\r\n",
    "PostedDate": "2009-03-27T13:11:27.543-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "172922",
    "ThreadId": "51553",
    "Html": "*** irrelevant ***<br>\r\n",
    "PostedDate": "2009-03-27T13:42:32.977-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "172926",
    "ThreadId": "51553",
    "Html": "*** irrelevant ***\r\n",
    "PostedDate": "2009-03-27T13:50:37.77-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "172979",
    "ThreadId": "51553",
    "Html": "Ok... one step further... I knew something really simple was going wrong, and I am embarrassed to admit, it was an event firing, and an event handler properly programmed, but the two not wired... classic mistake. All it took was :<br>\r\n<br>\r\n// XAML<br>\r\n&lt;toolkit:DataGrid x:Name=&quot;dgCustomers&quot; &nbsp;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AutoGenerateColumns=&quot;False&quot;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsSynchronizedWithCurrentItem=&quot;True&quot;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RowEditEnding=&quot;dgCustomers_RowEditEnding&quot;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;toolkit:DataGrid.Columns&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;toolkit:DataGridTextColumn Header=&quot;First Name&quot; Binding=&quot;{Binding FirstName, Mode=TwoWay}&quot; /&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;toolkit:DataGridTextColumn Header=&quot;Initial&quot; Binding=&quot;{Binding MiddleInitial, Mode=TwoWay}&quot; /&gt;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>\r\n<br>\r\n// C# Loaded<br>\r\ndgCustomers.ItemSource = myEntities.Customers;<br>\r\n<br>\r\n// C# RowEditEnding Event Handler<br>\r\nICollectionView cv = CollectionViewSource.GetDefaultView(dgCustomers.ItemsSource);<br>\r\nIEditableCollectionView iecv = cv as IEditableCollectionView;<br>\r\niecv.CommitEdit();<br>\r\nentities.SaveChanges();<br>\r\n<br>\r\n<br>\r\nThat seems to do it... Where I am stuck now is what event handlers take care of operations like Add and Delete? I could not find something like RowAddEnding or something similarly intuitive. And if I add a row now, the RowEditEnding still fires and throws and exception on CommitEdit().<br>\r\n<br>\r\nAnyone have some words of wisdom or examples for handling the add and delete operations?<br>\r\n<br>\r\nThank you.<br>\r\n",
    "PostedDate": "2009-03-27T17:18:36.047-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "172980",
    "ThreadId": "51553",
    "Html": "Just for testing I removed all three lines regarding the collection views from the event handler... &quot;entities.SaveChanges()&quot; was all it took to perpetuate row changes to the db.<br>\r\n<br>\r\nInterestingly enough, If I add a new row via the grid, when it loses focus, nothing is added (but still remains on the grid)... and then edit a cell in an existing row, both the changes to that row, and the new row are perpetuated. Not good.<br>\r\n",
    "PostedDate": "2009-03-27T17:25:26.543-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "173544",
    "ThreadId": "51553",
    "Html": "Hello trov2k,<br>\r\n<br>\r\nThe problem here is RowEditEnding gets raised before the actual commit is performed on the Row. So in case of adding a new row, the row is not added to the itemssource yet. Hence it doesnt get saved to the DB. Unfortunately currently we dont have a RowEditEnded event. One of the options could be to do a Dispatcher.BeginInvoke which executes entities.SaveChanges, so that by the time it gets called row is already committed.\r\n",
    "PostedDate": "2009-03-30T10:17:53.583-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "174420",
    "ThreadId": "51553",
    "Html": "VamseeP-<br>\r\nThank you very much for your reply. Out of all my posts across dozens of relative sites, you are the only one yet. After what you said, I am concerned with my specific data model and how it is changing the connections with the DataGrid part. I never use views or commit changes, only save the entities in the ending event. Here's all I got:<br>\r\n<br>\r\n<em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void dgCustomers_RowEditEnding(object sender, Microsoft.Windows.Controls.DataGridRowEditEndingEventArgs e)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entities.SaveChanges();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</em><br>\r\n<br>\r\nThis code updates the grid visually immediately and the changes are posted to the database properly as soon as the row is completed (ex. clicking on another row, tab off the last field, or enter). <br>\r\n<br>\r\nIs this a bad thing? If what you say is true, how would this work? If this code is enough, what are the event handlers I should use for Adds and Deletes from the grid?<br>\r\n<br>\r\nThanks. \r\n",
    "PostedDate": "2009-04-01T10:40:08.773-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "174571",
    "ThreadId": "51553",
    "Html": "I've gotten one step further it seems:<br>\r\n<br>\r\n<em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void dgCustomers_RowEditEnding(object sender, Microsoft.Windows.Controls.DataGridRowEditEndingEventArgs e)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ICollectionView cv = CollectionViewSource.GetDefaultView(dgCustomers.Items);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEditableCollectionView iecv = (IEditableCollectionView)cv;<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iecv.IsAddingNew)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iecv.CommitNew();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iecv.IsEditingItem)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iecv.CommitEdit();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entities.SaveChanges();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n</em><br>\r\nIf I understand what you are saying, the CommitNew() function forces the new grid row into its items collection bound via ItemsSource, and thus when the entities are saved it is persisted back to the db. Tested and it seems to work. As always, not without complications. I am stuck/confused on two things now:<br>\r\n<br>\r\n1. The CommitEdit() seems unnecessary. Whether that entire clause is present or just the entities.SaveChanges() call, the edits are pushed properly to the db and it all stays in sync. If I understand your point about timing, the edit is commited after this handler is run. So what's got me confused is why does it work without the explicit CommitEdit() function? If the only code in the handler is the single entities.SaveChanges() line, something is commiting them before... that or there is something about the way edits are performed against a bound EntityObject that I'm not understanding.<br>\r\n<br>\r\n2. After adding a row to the database (works fine), but if I add a new row again or edit an existing row, it throws an InvalidOperationException. Note that the add or edit is committed successfully and reflected in the database table, but this exception is saying that it could not update the ObjectContext. The error is below:<br>\r\n<blockquote><em>The changes to the database were committed successfully, but an error occurred while updating the object context. The ObjectContext might be in an inconsistent state. Inner exception message: AcceptChanges cannot continue because the object's key values conflict with another object in the ObjectStateManager. Make sure that the key values are unique before calling AcceptChanges.</em><br>\r\n</blockquote>I understanding it is having commited an Add to the collection that caused this... but not quite sure about the logic behind that. If the DataGrid control commits and edit or add to it's collection, and that collection is syncing with the entity object it is bound to every time &quot;SaveChanges&quot; is called, how are they getting out of sync? Also, what is the &quot;AcceptChanges&quot; method/function? Where is it and what is firing it?<br>\r\n<br>\r\nThank you ahead of time. Hopefully these are legit inquiries to you guys. -T<br>\r\n",
    "PostedDate": "2009-04-01T16:12:02.013-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "176819",
    "ThreadId": "51553",
    "Html": "Any further information on these two topics? I feel like I am so close, but thoroughly stuck here.<br>\r\n",
    "PostedDate": "2009-04-07T13:50:01.663-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]