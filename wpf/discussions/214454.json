[
  {
    "Id": "449572",
    "ThreadId": "214454",
    "Html": "<p>If a chart only contains 1 single datetime value the chart will generate a Nullreference exception (see below).</p>\r\n<p>1 single&nbsp;datapoint in a chart item will cause this, but also multiple datapoints with the same datetime value. If I set a minimum and maximum value in the XAML it works well, but if I want to bind to a maximum value that I make let's say a minute more than the maximum datapoint datetime value I'm back to the same exception again.</p>\r\n<p>If somebody already found a workaround for this I would be truly happy!</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DateTimeAxis.OverrideDataRange(Range`1 range) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Axis\\DateTimeAxis.cs:line 989<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.RangeAxis.&lt;UpdateActualRange&gt;b__9() in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Axis\\RangeAxis.cs:line 293<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.RangeAxis.UpdateActualRange() in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Axis\\RangeAxis.cs:line 308<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.RangeAxis.OnObjectRegistered(IAxisListener series) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Axis\\RangeAxis.cs:line 522<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.Axis.RegisteredListenersCollectionChanged(Object sender, NotifyCollectionChangedEventArgs e) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Axis\\Axis.cs:line 216<br>&nbsp;&nbsp; at System.Collections.Specialized.NotifyCollectionChangedEventHandler.Invoke(Object sender, NotifyCollectionChangedEventArgs e)<br>&nbsp;&nbsp; at System.Collections.ObjectModel.ObservableCollection`1.OnCollectionChanged(NotifyCollectionChangedEventArgs e)<br>&nbsp;&nbsp; at System.Collections.ObjectModel.ObservableCollection`1.InsertItem(Int32 index, T item)<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.UniqueObservableCollection`1.InsertItem(Int32 index, T item) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\UniqueObservableCollection.cs:line 26<br>&nbsp;&nbsp; at System.Collections.ObjectModel.Collection`1.Add(T item)<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSeriesWithAxes.GetAxes(DataPoint firstDataPoint, Func`2 independentAxisPredicate, Func`1 independentAxisFactory, Func`2 dependentAxisPredicate, Func`1 dependentAxisFactory) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSeriesWithAxes.cs:line 489<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.LineSeries.GetAxes(DataPoint firstDataPoint) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\LineSeries.cs:line 98<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSeriesWithAxes.GetAxes() in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSeriesWithAxes.cs:line 394<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSeriesWithAxes.OnDataPointsChanged(IList`1 newDataPoints, IList`1 oldDataPoints) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSeriesWithAxes.cs:line 319<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSingleSeriesWithAxes.OnDataPointsChanged(IList`1 newDataPoints, IList`1 oldDataPoints) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSingleSeriesWithAxes.cs:line 277<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.LineAreaBaseSeries`1.OnDataPointsChanged(IList`1 newDataPoints, IList`1 oldDataPoints) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\LineAreaBaseSeries.cs:line 168<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSeries.LoadDataPoints(IEnumerable newItems, IEnumerable oldItems) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSeries.cs:line 826<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSeries.Refresh() in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSeries.cs:line 994<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSeries.OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSeries.cs:line 232<br>&nbsp;&nbsp; at System.Windows.Controls.DataVisualization.Charting.DataPointSeries.OnItemsSourceChanged(DependencyObject o, DependencyPropertyChangedEventArgs e) in C:\\dd\\WPF_1\\src\\wpf\\src\\ControlsPack\\WPFToolkit\\DataVisualization\\Charting\\Series\\DataPointSeries.cs:line 197<br>&nbsp;&nbsp; at System.Windows.DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs e)<br>&nbsp;&nbsp; at System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs e)<br>&nbsp;&nbsp; at System.Windows.DependencyObject.NotifyPropertyChange(DependencyPropertyChangedEventArgs args)<br>&nbsp;&nbsp; at System.Windows.DependencyObject.UpdateEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry oldEntry, EffectiveValueEntry&amp; newEntry, Boolean coerceWithDeferredReference, OperationType operationType)<br>&nbsp;&nbsp; at System.Windows.DependencyObject.InvalidateProperty(DependencyProperty dp)<br>&nbsp;&nbsp; at System.Windows.Data.BindingExpression.Invalidate(Boolean isASubPropertyChange)<br>&nbsp;&nbsp; at System.Windows.Data.BindingExpression.TransferValue(Object newValue, Boolean isASubPropertyChange)<br>&nbsp;&nbsp; at System.Windows.Data.BindingExpression.Activate(Object item)<br>&nbsp;&nbsp; at System.Windows.Data.BindingExpression.AttachToContext(AttachAttempt attempt)<br>&nbsp;&nbsp; at System.Windows.Data.BindingExpression.MS.Internal.Data.IDataBindEngineClient.AttachToContext(Boolean lastChance)<br>&nbsp;&nbsp; at MS.Internal.Data.DataBindEngine.Task.Run(Boolean lastChance)<br>&nbsp;&nbsp; at MS.Internal.Data.DataBindEngine.Run(Object arg)<br>&nbsp;&nbsp; at MS.Internal.Data.DataBindEngine.OnLayoutUpdated(Object sender, EventArgs e)<br>&nbsp;&nbsp; at System.Windows.ContextLayoutManager.fireLayoutUpdateEvent()<br>&nbsp;&nbsp; at System.Windows.ContextLayoutManager.UpdateLayout()<br>&nbsp;&nbsp; at System.Windows.UIElement.UpdateLayout()<br>&nbsp;&nbsp; at System.Windows.Interop.HwndSource.SetLayoutSize()<br>&nbsp;&nbsp; at System.Windows.Interop.HwndSource.set_RootVisualInternal(Visual value)<br>&nbsp;&nbsp; at System.Windows.Interop.HwndSource.set_RootVisual(Visual value)<br>&nbsp;&nbsp; at System.Windows.Window.SetRootVisual()<br>&nbsp;&nbsp; at System.Windows.Window.SetupInitialState(Double requestedTop, Double requestedLeft, Double requestedWidth, Double requestedHeight)<br>&nbsp;&nbsp; at System.Windows.Window.CreateSourceWindowImpl()<br>&nbsp;&nbsp; at System.Windows.Window.SafeCreateWindow()<br>&nbsp;&nbsp; at System.Windows.Window.ShowHelper(Object booleanBox)<br>&nbsp;&nbsp; at System.Windows.Window.Show()<br>&nbsp;&nbsp; at System.Windows.Window.ShowDialog()</p>",
    "PostedDate": "2010-05-31T05:23:11.433-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "462759",
    "ThreadId": "214454",
    "Html": "Hi,\r\n<br><br>\r\nI seem to be running into the same problem.\r\n<br><br>\r\n- In DateTimeAxis.OverrideDataRange(), there's a &quot;while (maxLeftOverlapValueMargin.LeftOverlap &gt; 0 || maxRightOverlapValueMargin.RightOverlap &gt; 0)&quot; loop.<br>\r\n- The crash occurs since maxLeftOverlapValueMargin is null.<br>\r\n- maxLeftOverlapValueMargin is found in the line right before that loop: GetMaxLeftAndRightOverlap(valueMargins, out maxLeftOverlapValueMargin, out maxRightOverlapValueMargin);<br>\r\n- GetMaxLeftAndRightOverlap() is defined in the RangeAxis as a static function. <br>\r\n- There's a check if (leftOverlap &gt; maxLeftOverlap) that does not seem to become true because at this point the leftOverlap = -Infinity...<br>\r\n- double leftOverlap = valueMargin.LeftOverlap where valueMargin is passed in as parameter.<br>\r\n<br><br>\r\nHas there been any update to this issue? Seems like there might be some boundary condition bug with this function?\r\n<br>\r\n\r\n\r\n\r\n",
    "PostedDate": "2010-07-02T11:18:45.657-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "462786",
    "ThreadId": "214454",
    "Html": "I managed to find a fix in DateTimeAxis.OverrideDataRange(). \r\n\r\n<br><br>\r\nIt's a little hacky as it simply bypasses the valueMargins that causes the crash. I guess there's something greater at work here but I don't understand the rest of the system :( \r\n\r\n<br><br>\r\n\r\nAnyway, replacing the while loop in the function with this will bypass null errors and -ve values.\r\n<br><br>\r\nwhile ( (maxLeftOverlapValueMargin != null && maxLeftOverlapValueMargin.LeftOverlap &gt; 0) || <br>\r\n          (maxRightOverlapValueMargin != null && maxRightOverlapValueMargin.RightOverlap &gt; 0))<br>\r\n{<br>\r\n          long unitOverPixels = currentRange.GetLength().Value.Ticks / ((long) actualLength);<br>\r\n          long minDateTimeTicks = currentRange.Minimum.Ticks;<br>\r\n          long maxDateTimeTicks = currentRange.Maximum.Ticks;<br>\r\n<br><br>\r\n           if(maxLeftOverlapValueMargin != null)<br>\r\n           {<br>\r\n                  long leftOverlapOffset = (long)((maxLeftOverlapValueMargin.LeftOverlap + 0.5) * unitOverPixels);<br>\r\n                  if (leftOverlapOffset &gt; 0)<br>\r\n                  {<br>\r\n                           minDateTimeTicks -= leftOverlapOffset;<br>\r\n                  }<br>\r\n                  Debug.Assert(maxDateTimeTicks &gt;= DateTime.MinValue.Ticks && maxDateTimeTicks &lt;= DateTime.MaxValue.Ticks);<br>\r\n         }<br>\r\n<br><br>\r\n         if (maxRightOverlapValueMargin != null)<br>\r\n         {<br>\r\n                  long rightOverlapOffset = (long)((maxRightOverlapValueMargin.RightOverlap + 0.5) * unitOverPixels);<br>\r\n                  if (rightOverlapOffset &gt; 0)<br>\r\n                  {<br>\r\n                              maxDateTimeTicks += rightOverlapOffset;<br>\r\n                   }<br>\r\n                   Debug.Assert(maxDateTimeTicks &gt;= DateTime.MinValue.Ticks && maxDateTimeTicks &lt;= DateTime.MaxValue.Ticks);<br>\r\n           }<br>\r\n<br><br>\r\n         DateTime newMinimum = new DateTime(minDateTimeTicks);<br>\r\n         DateTime newMaximum = new DateTime(maxDateTimeTicks);<br>\r\n<br><br>\r\n         currentRange = new Range&lt;DateTime&gt;(newMinimum, newMaximum);<br>\r\n         UpdateValueMargins(valueMargins, currentRange.ToComparableRange());<br>\r\n         GetMaxLeftAndRightOverlap(valueMargins, out maxLeftOverlapValueMargin, out maxRightOverlapValueMargin);<br>\r\n }<br>\r\n\r\n<br><br>\r\nPlease let us know if anyone knows of a proper fix!\r\n<br>\r\n\r\n",
    "PostedDate": "2010-07-02T12:20:32.397-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "568731",
    "ThreadId": "214454",
    "Html": "<p>Any update with this issue?</p>",
    "PostedDate": "2011-02-18T12:36:53.163-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]