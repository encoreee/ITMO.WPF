{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "I am using latest WPF toolkit (3.5.40128.1) release on February 2010.\nÂ \nI have a datepicker control that starts as IsEnabled=False. Then in code, I try to enable it but it will still be displayed as disable, even though I am able to select a date, the controls appearance is as if it were disable",
    "LastUpdatedDate": "2013-02-21T18:40:21.973-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "wpf",
    "ReportedDate": "2010-09-17T02:50:40.433-07:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "DatePicker IsEnabled=true does not change the disable appearance of the control",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 7,
    "Id": 14273
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "I believe this is due to an issue in the property changed callback method for the IsEnabled dp on the DatePicker. I tried altering the method a bit and the visual state is adhered correctly afterwards. Example:\r\n\r\n        private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\r\n        {\r\n            DatePicker dp = d as DatePicker;\r\n            Debug.Assert(dp != null);\r\n\r\n            dp.CoerceValue(IsDropDownOpenProperty);\r\n\r\n            // This is the code that is in the original bits. If there aren't any errors on the dp, it will allways set the VisualStates.StateValid visual state.\r\n            //OnVisualStatePropertyChanged(dp);\r\n\r\n            // This is the modification made. If the new value for the IsEnabled dp is True, the Normal visual state is applied, otherwise the Disabled visual state is applied.\r\n            bool isEnabled = Convert.ToBoolean(e.NewValue);\r\n            if (isEnabled)\r\n                VisualStateManager.GoToState(dp, VisualStates.StateNormal, true);\r\n            else\r\n                VisualStateManager.GoToState(dp, VisualStates.StateDisabled, true);\r\n        }",
      "PostedDate": "2010-09-22T21:56:22.247-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2010-09-28T21:31:08.97-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2010-10-22T02:15:18.55-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2010-10-25T08:47:49.463-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2010-11-15T09:09:46.793-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2011-01-28T03:50:14.73-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2011-01-28T08:27:55.043-08:00",
      "Id": -2147483648
    },
    {
      "Message": "If you don't want to change or re-compile  source code, it's possible to set IsEnabledChanged to an event handler with the same code as above.\r\n\r\n        private void DatePicker_IsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e)\r\n        {\r\n            var dp = sender as Microsoft.Windows.Controls.DatePicker;\r\n            if ( dp.IsEnabled )\r\n                VisualStateManager.GoToState(dp, \"Normal\", true);\r\n            else\r\n                VisualStateManager.GoToState(dp, \"Disabled\", true);\r\n        }",
      "PostedDate": "2011-01-28T08:37:56.73-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Setting explicitely VisualState subscribing \"IsEnabledChanged\" doesn't work for me in some cases.\r\n",
      "PostedDate": "2011-08-11T00:13:03.407-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-21T18:40:21.973-08:00",
      "Id": -2147483648
    }
  ]
}