        private bool CanEndEdit(CanExecuteRoutedEventArgs e, bool commit)
        {
            DataGridCell cellContainer = GetEventCellOrCurrentCell(e);
            if (cellContainer == null)
            {
                return true;
            }
            ....
        }

        protected virtual void OnExecutedCommitEdit(ExecutedRoutedEventArgs e)
        {
            DataGridCell cell = CurrentCellContainer;
            bool validationPassed = true;
            if (cell != null)
            {
                ....
            }
            else if (_editingRowItem != null)
            {
                Object rowDataItem = _editingRowItem;
                DataGridRow rowOwner = this.ItemContainerGenerator.ContainerFromItem(_editingRowItem) as DataGridRow;

                DataGridEditingUnit editingUnit = GetEditingUnit(e.Parameter);

                bool eventCanceled = false;

                if (validationPassed &&
                    !eventCanceled &&
                    (((editingUnit == DataGridEditingUnit.Row) && IsAddingOrEditingRowItem(rowDataItem)) ||
                     (!EditableItems.CanCancelEdit && IsEditingItem(rowDataItem))))
                {
                    DataGridRowEditEndingEventArgs rowEditEndingEventArgs = new DataGridRowEditEndingEventArgs(rowOwner, DataGridEditAction.Commit);
                    OnRowEditEnding(rowEditEndingEventArgs);

                    if (!rowEditEndingEventArgs.Cancel)
                    {
                        var bindingGroup = rowOwner.BindingGroup;
                        if (bindingGroup != null)
                        {
                            // CommitEdit will invoke the bindingGroup's ValidationRule's, so we need to make sure that all of the BindingExpressions
                            // have already registered with the BindingGroup.  Synchronously flushing the Dispatcher to DataBind priority lets us ensure this.
                            // Had we used BeginInvoke instead, IsEditing would not reflect the correct value.
                            Dispatcher.Invoke(new DispatcherOperationCallback(DoNothing), DispatcherPriority.DataBind, bindingGroup);
                            validationPassed = bindingGroup.CommitEdit();
                        }

                        HasRowValidationError = !validationPassed;
                        if (validationPassed)
                        {
                            CommitRowItem();
                        }
                    }
                }

                if (validationPassed)
                {
                    // Update the state of row editing
                    rowOwner.IsEditing = false;
                }

                // CancelEdit and CommitEdit rely on IsAddingNewItem and IsEditingRowItem
                CommandManager.InvalidateRequerySuggested();
            }
            ...
        }

        protected virtual void OnExecutedCancelEdit(ExecutedRoutedEventArgs e)
        {
            DataGridCell cell = CurrentCellContainer;
            if (cell != null)
            {
                ...
            }
            else if (_editingRowItem != null)
            {
                Object rowDataItem = _editingRowItem;
                DataGridRow rowOwner = this.ItemContainerGenerator.ContainerFromItem(_editingRowItem) as DataGridRow;

                DataGridEditingUnit editingUnit = GetEditingUnit(e.Parameter);

                bool eventCanceled = false;

                var editableItems = EditableItems;
                bool needsCommit = IsEditingItem(rowDataItem) && !editableItems.CanCancelEdit;
                if (!eventCanceled &&
                    (CanCancelAddingOrEditingRowItem(editingUnit, rowDataItem) || needsCommit))
                {
                    bool cancelAllowed = true;

                    if (!needsCommit)
                    {
                        DataGridRowEditEndingEventArgs rowEditEndingEventArgs = new DataGridRowEditEndingEventArgs(rowOwner, DataGridEditAction.Cancel);
                        OnRowEditEnding(rowEditEndingEventArgs);
                        cancelAllowed = !rowEditEndingEventArgs.Cancel;
                    }

                    if (cancelAllowed)
                    {
                        if (needsCommit)
                        {
                            // If the row is being edited (not added), but it doesn't support
                            // pending changes, then tell the item to commit (this doesn't really
                            // do anything except update the IEditableCollectionView state).
                            // This allows us to exit row editing mode.
                            editableItems.CommitEdit();
                        }
                        else
                        {
                            CancelRowItem();
                        }

                        var bindingGroup = rowOwner.BindingGroup;
                        if (bindingGroup != null)
                        {
                            bindingGroup.CancelEdit();

                            // This is to workaround the bug that BindingGroup 
                            // does nor clear errors on CancelEdit
                            bindingGroup.UpdateSources();
                        }
                    }
                }

                rowOwner.IsEditing = false;
                HasRowValidationError = false;

                // CancelEdit and CommitEdit rely on IsAddingNewItem and IsEditingRowItem
                CommandManager.InvalidateRequerySuggested();
            }
            ...
        }
