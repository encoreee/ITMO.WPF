{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "I have a small WPF application where I am testing Ribbon for WPF (October 2010 version). DataContext of MainWindow (RibbonWindow instance) is set in its Loaded event to itself and it has public ICommand property to which is bound one RibbonApplicationMenuItem (it has same DataContext as MainWindow). When I try to add this RibbonApplicationMenuItem to Quick Access Toolbar application throws StackOverflowException. I investigated that it tries repeatedly to create new instances of MainWindow so that creates infinite loop.\n \nWhy is it trying to clone DataContext property of RibbonApplicationMenuItem when adding to Quick Access Toolbar?\n \nI know that this isn't right usage. In real application it works perfectly because DataContext is set to data model classes.\n \nCall Stack:\n>\tWpfRibbonApp.exe!WpfRibbonApp.MainWindow.MainWindow() Line 30\tC#\n \tmscorlib.dll!System.Activator.CreateInstance(System.Type type, bool nonPublic) + 0x46 bytes\t\n \tmscorlib.dll!System.Activator.CreateInstance(System.Type type) + 0x7 bytes\t\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.CreateInstance(System.Windows.FrameworkElement original, bool allowTransformations) Line 1935 + 0x15 bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.CreateClone(object original, bool allowTransformations) Line 1848 + 0xd bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.CreateClone(object original) Line 1837 + 0xb bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.TransferProperty(System.Windows.UIElement original, System.Windows.UIElement clone, System.Windows.DependencyProperty originalProperty, System.Windows.DependencyProperty cloneProperty, Microsoft.Windows.Controls.Ribbon.RibbonHelper.TransferMode mode) Line 1562 + 0x15 bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.TransferProperty(System.Windows.UIElement original, System.Windows.UIElement clone, System.Windows.DependencyProperty dp, Microsoft.Windows.Controls.Ribbon.RibbonHelper.TransferMode mode) Line 1517 + 0x15 bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.TransferProperties(System.Windows.FrameworkElement original, System.Windows.FrameworkElement clone, Microsoft.Windows.Controls.Ribbon.RibbonHelper.PropertyAndTransferMode[] properties) Line 2184 + 0x39 bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.TransferProperties(System.Windows.FrameworkElement original, System.Windows.FrameworkElement clone, bool cloningForTemplatePart) Line 2075 + 0x12 bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonHelper.CreateClone(object original, bool allowTransformations) Line 1853 + 0xe bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.Ribbon.OnCloneThunk(object sender, Microsoft.Windows.Controls.Ribbon.RibbonQuickAccessToolBarCloneEventArgs e) Line 2634 + 0x20 bytes\tC#\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.RibbonQuickAccessToolBarCloneEventArgs.InvokeEventHandler(System.Delegate genericHandler, object genericTarget) Line 52 + 0x11 bytes\tC#\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target) + 0x36 bytes\t\n \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs) + 0x40 bytes\t\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised) + 0x1ae bytes\t\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args) + 0x79 bytes\t\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs e) + 0x29 bytes\t\n \tRibbonControlsLibrary.dll!Microsoft.Windows.Controls.Ribbon.Ribbon.AddToQATExecuted(object sender, System.Windows.Input.ExecutedRoutedEventArgs args) Line 2448 + 0xd bytes\tC#\n \tPresentationCore.dll!System.Windows.Input.CommandBinding.OnExecuted(object sender, System.Windows.Input.ExecutedRoutedEventArgs e) + 0x65 bytes\t\n \tPresentationCore.dll!System.Windows.Input.CommandManager.ExecuteCommandBinding(object sender, System.Windows.Input.ExecutedRoutedEventArgs e, System.Windows.Input.CommandBinding commandBinding) + 0x98 bytes\t\n \tPresentationCore.dll!System.Windows.Input.CommandManager.FindCommandBinding(System.Windows.Input.CommandBindingCollection commandBindings, object sender, System.Windows.RoutedEventArgs e, System.Windows.Input.ICommand command, bool execute) + 0x109 bytes\t\n \tPresentationCore.dll!System.Windows.Input.CommandManager.FindCommandBinding(object sender, System.Windows.RoutedEventArgs e, System.Windows.Input.ICommand command, bool execute) + 0x166 bytes\t\n \tPresentationCore.dll!System.Windows.Input.CommandManager.OnExecuted(object sender, System.Windows.Input.ExecutedRoutedEventArgs e) + 0x26 bytes\t\n \tPresentationCore.dll!System.Windows.UIElement.OnExecutedThunk(object sender, System.Windows.Input.ExecutedRoutedEventArgs e) + 0x46 bytes\t\n \tPresentationCore.dll!System.Windows.Input.ExecutedRoutedEventArgs.InvokeEventHandler(System.Delegate genericHandler, object target) + 0x3e bytes\t\n \tPresentationCore.dll!System.Windows.RoutedEventArgs.InvokeHandler(System.Delegate handler, object target) + 0x36 bytes\t\n \tPresentationCore.dll!System.Windows.RoutedEventHandlerInfo.InvokeHandler(object target, System.Windows.RoutedEventArgs routedEventArgs) + 0x40 bytes\t\n \tPresentationCore.dll!System.Windows.EventRoute.InvokeHandlersImpl(object source, System.Windows.RoutedEventArgs args, bool reRaised) + 0x1ae bytes\t\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEventImpl(System.Windows.DependencyObject sender, System.Windows.RoutedEventArgs args) + 0x79 bytes\t\n \tPresentationCore.dll!System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs args, bool trusted) + 0x33 bytes\t\n \tPresentationCore.dll!System.Windows.Input.RoutedCommand.ExecuteImpl(object parameter, System.Windows.IInputElement target, bool userInitiated) + 0x113 bytes\t\n \tPresentationCore.dll!System.Windows.Input.RoutedCommand.ExecuteCore(object parameter, System.Windows.IInputElement target, bool userInitiated) + 0x5b bytes\t\n \tPresentationFramework.dll!MS.Internal.Commands.CommandHelpers.CriticalExecuteCommandSource(System.Windows.Input.ICommandSource commandSource, bool userInitiated) + 0x7d bytes\t\n \tPresentationFramework.dll!System.Windows.Controls.MenuItem.InvokeClickAfterRender(object arg) + 0x62 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) + 0x53 bytes\t\n \tWindowsBase.dll!MS.Internal.Threading.ExceptionFilterHelper.TryCatchWhen(object source, System.Delegate method, object args, int numArgs, System.Delegate catchHandler) + 0x42 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeImpl() + 0x8d bytes\t\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.InvokeInSecurityContext(object state) + 0x38 bytes\t\n \tmscorlib.dll!System.Threading.ExecutionContext.runTryCode(object userData) + 0x51 bytes\t\n \t[Native to Managed Transition]\t\n \t[Managed to Native Transition]\t\n \tmscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) + 0x6a bytes\t\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool ignoreSyncCtx) + 0x7e bytes\t\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) + 0x2c bytes\t\n \tWindowsBase.dll!System.Windows.Threading.DispatcherOperation.Invoke() + 0x68 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.ProcessQueue() + 0x15e bytes\t\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.WndProcHook(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) + 0x63 bytes\t\n \tWindowsBase.dll!MS.Win32.HwndWrapper.WndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam, ref bool handled) + 0xbe bytes\t\n \tWindowsBase.dll!MS.Win32.HwndSubclass.DispatcherCallbackOperation(object o) + 0x7d bytes\t\n \tWindowsBase.dll!System.Windows.Threading.ExceptionWrapper.InternalRealCall(System.Delegate callback, object args, int numArgs) + 0x53 bytes\t\n \tWindowsBase.dll!MS.Internal.Threading.ExceptionFilterHelper.TryCatchWhen(object source, System.Delegate method, object args, int numArgs, System.Delegate catchHandler) + 0x42 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.InvokeImpl(System.Windows.Threading.DispatcherPriority priority, System.TimeSpan timeout, System.Delegate method, object args, int numArgs) + 0xb4 bytes\t\n \tWindowsBase.dll!MS.Win32.HwndSubclass.SubclassWndProc(System.IntPtr hwnd, int msg, System.IntPtr wParam, System.IntPtr lParam) + 0x104 bytes\t\n \t[Native to Managed Transition]\t\n \t[Managed to Native Transition]\t\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrameImpl(System.Windows.Threading.DispatcherFrame frame) + 0xc1 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame frame) + 0x49 bytes\t\n \tWindowsBase.dll!System.Windows.Threading.Dispatcher.Run() + 0x4c bytes\t\n \tPresentationFramework.dll!System.Windows.Application.RunDispatcher(object ignore) + 0x17 bytes\t\n \tPresentationFramework.dll!System.Windows.Application.RunInternal(System.Windows.Window window) + 0x6f bytes\t\n \tPresentationFramework.dll!System.Windows.Application.Run(System.Windows.Window window) + 0x26 bytes\t\n \tPresentationFramework.dll!System.Windows.Application.Run() + 0x1b bytes\t\n \tWpfRibbonApp.exe!WpfRibbonApp.App.Main() + 0x5e bytes\tC#\n \t[Native to Managed Transition]\t\n \t[Managed to Native Transition]\t\n \tmscorlib.dll!System.AppDomain.ExecuteAssembly(string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args) + 0x6d bytes\t\n \tMicrosoft.VisualStudio.HostingProcess.Utilities.dll!Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly() + 0x2a bytes\t\n \tmscorlib.dll!System.Threading.ThreadHelper.ThreadStart_Context(object state) + 0x63 bytes\t\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool ignoreSyncCtx) + 0xb0 bytes\t\n \tmscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) + 0x2c bytes\t\n \tmscorlib.dll!System.Threading.ThreadHelper.ThreadStart() + 0x44 bytes\t\n \t[Native to Managed Transition]",
    "LastUpdatedDate": "2013-02-21T18:40:12.107-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "wpf",
    "ReportedDate": "2011-06-01T22:32:35.977-07:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Add to Quick Access Toolbar throws StackOverflowException",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 2,
    "Id": 15955
  },
  "FileAttachments": [],
  "Comments": []
}