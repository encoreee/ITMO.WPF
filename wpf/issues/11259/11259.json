{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "The attached project demonstrates a performance issue with the charting controls.  The application has 3 tabs with 2 charts on each tab.  The data that the charts are bound to updates every second.\n \nTo recreate the problem:\n   1) Launch the application\n   2) Click on each tab\n   3) Let the application run for 10-15 minutes\n \nYou will notice the memory and CPU usage gradually increase as time goes on.  Also, the 2 charts that are visible will begin to fall behind in their updates.  After about 15 minutes, click on one of the other tabs.  For several minutes the CPU will be pegged and the memory usage will rapidly increase.  It takes a long time for the tabs to switch and for the charts on the new tab to draw.\n \nIf you take the same application and remove the tabs so all 6 of the charts are visible, it performs much better.\n \nI ran these tests on a 2GHz processor with 1.5 GB RAM running Windows XP.  If you are running on a better PC you may need to let the application run longer.\n \nThe sample application is using \"WPF Data Visualization Development Release 3\".\n \nThere are buttons at the bottom of the application to force garbage collection and to start/stop the updates to the data, I hope that helps.",
    "LastUpdatedDate": "2013-02-21T18:40:48.657-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "wpf",
    "ReportedDate": "2009-12-18T11:33:09.58-08:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Charts: Performance issues with charts on a tabbed interface",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 11259
  },
  "FileAttachments": [
    {
      "FileId": 3619,
      "FileName": "ChartingMemoryTest.zip",
      "DownloadUrl": ".\\3619"
    },
    {
      "FileId": 3620,
      "FileName": "ChartingMemoryTest_Workaround.zip",
      "DownloadUrl": ".\\3620"
    }
  ],
  "Comments": [
    {
      "Message": "Thanks for the great write-up and for attaching what sounds like a great demonstration of the problem! This sounds similar to the following issue in the Silverlight Toolkit database: http://silverlight.codeplex.com/WorkItem/View.aspx?WorkItemId=2677\r\n\r\nWhile we'd like very much to get to the bottom of this, we haven't had the resources to do so yet. :( I realize that's frustrating; sorry. It could be helpful that your application is in WPF because there are some tools available to investigate problems like this for WPF that don't exist for Silverlight.\r\n\r\nI'll do my best to look into this soon, but I'm afraid I'll be unable to get to it for the remainder of this month due to the holiday season in the US.\r\n\r\nIn the meantime, you might consider stopping updates for the invisible charts and/or removing those charts entirely when they're invisible. If you can't do that, it might help to simply set the ItemsSource to NULL for those charts and restore it when they become visible again. Other things you might consider include simpler DataPoint Templates (I hope to blog about this soon), removing VSM states, and performing fewer updates with less data.\r\n\r\nThanks very much for your patience - again, sorry for the trouble.",
      "PostedDate": "2009-12-18T12:39:01.667-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Based on davidans's response, I implemented the following workaround (see updated attachment):\r\n\r\n   1) Store the DataContext for the Chart in the Tag property (I could have used an attached property, but this was faster)\r\n   2) Handle the IsVisibleChanged event\r\n   3) If the Chart is not visible, set the DataContext to null.  If the Chart is Visible, set the DataContext to the value of the Tag property.\r\n\r\nThis seems to have fixed the performance problem.\r\n",
      "PostedDate": "2009-12-18T13:46:15.97-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-12-18T13:46:21.78-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-21T18:40:48.657-08:00",
      "Id": -2147483648
    }
  ]
}